/*
 * generated by Xtext 2.37.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.myDsl.Config
import org.xtext.example.mydsl.myDsl.Entry
import org.xtext.example.mydsl.myDsl.Exp
import org.xtext.example.mydsl.myDsl.StringConstraint
import org.xtext.example.mydsl.myDsl.IntConstraint
import org.xtext.example.mydsl.myDsl.BoolConstraint
import org.xtext.example.mydsl.myDsl.IPConstraint
import org.xtext.example.mydsl.myDsl.And


/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {
	
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
        var root = resource.allContents.toIterable.filter(Config).get(0)
	    fsa.generateFile("configTests/"+root.name+".java", root.compile())
    }
    
    def compile(Config root)'''
    	import com.fasterxml.jackson.databind.JsonNode;
    	import com.fasterxml.jackson.databind.ObjectMapper;
    	import org.junit.jupiter.api.Test;
    	import static org.junit.jupiter.api.Assertions.*;
    	
    	import java.io.File;
    	import java.io.IOException;
    	
    	public class «root.name»Tests {
    		// Assuming File is named config.json
    		File jsonFile = new File("config.json");
    		ObjectMapper objectMapper = new ObjectMapper();
    		JsonNode rootNode = objectMapper.readTree(jsonFile);
    		
    		@Test
    		public void testConfigJsonStructure() throws IOException {
    			
    			
    			assertNotNull(rootNode);
    			«FOR entry : root.entries»
    			    assertTrue(rootNode.has("«entry.name»"));
    			    «IF !entry.entries.empty»
    			        JsonNode «entry.name» = rootNode.get("«entry.name»");
    			        «HelperClass.generateAssertions(entry, entry.name)»
    			    «ENDIF»
    			«ENDFOR»
    			
    		}
    		
    		«FOR entry : root.entries»
    		    «IF !entry.entries.empty»
    		    	«HelperClass.generateTests(entry)»
    		    «ELSE»
    		    	// Test for entry:«entry.name»
    		    	@Test
    		    	def void «entry.name»Test() {
    		    		«HelperClass.compileExp(entry.type, entry, entry)»;
    		    	}
    		    «ENDIF»
    		«ENDFOR»
    		
    	}
    '''
    
}
    
class HelperClass {
    static def generateAssertions(Entry entry, String parentName) '''
        «FOR subEntry : entry.entries»
            assertTrue(«parentName».has("«subEntry.name»"));
            «IF !subEntry.entries.empty»
                JsonNode «subEntry.name» = «parentName».get("«subEntry.name»");
                «generateAssertions(subEntry, subEntry.name)»
            «ENDIF»
        «ENDFOR»
    '''
    static def generateTests(Entry entry) '''
        «FOR subEntry : entry.entries»
        	«IF !subEntry.entries.empty»
        		«generateTests(subEntry)»
        	«ELSE»
        		// Test for entry: «subEntry.name»
        		@Test
        		def void «subEntry.name»Test() {
        			«subEntry.type.compileExp(subEntry, entry)»;
        		}
        	«ENDIF»
        «ENDFOR»
    '''
   
   static def String compileExp(Exp exp, Entry entry, Entry parentEntry) {
   	
		if (exp instanceof And) {
    		return exp.left.compileExp(entry, parentEntry) + "\n" + exp.right.compileExp(entry, parentEntry);
		} else if (exp instanceof StringConstraint) {
			if(exp.constraint.equals('=')){
				return "assertTrue(" + parentEntry.name+".get("+"\""+entry.name+"\""+").equals("+"\""+exp.value+"\"))";
			} else if(exp.constraint.equals('!=')){
				return "assertTrue(!" + parentEntry.name+".get("+"\""+entry.name+"\""+").equals("+"\""+exp.value+"\"))";
			}
		} else if (exp instanceof IntConstraint) {
			return "assertTrue("+parentEntry.name+".get("+"\""+entry.name+"\""+")"+ exp.constraint +exp.value +")";
			
		}
	} 
}


    
   
